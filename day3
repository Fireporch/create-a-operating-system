为IPL（启动装载程序）装载程序
PS：其实程序还有别的什么东西都是一堆抽象的东西，他们只会做一种工作，比如CPU只是被设计了一个电路，然后同时传给他0011与0110，能输出1001的电信号，人才会将他就读为3+6=9
CPU根本不懂什么数字，只是能一直给出正确的运算


指令添加部分：
			MOV AX，0x0820
			MOV ES,AX
			MOV CH,0		;柱面0
			MOV DH,0		;磁头0
			MOV CL,2		;扇区2


			MOV AH,0x02		;AH=0x02，读盘
			MOV AL,1		;1个扇区
			MOV BX,0		
			MOV DL,0x00		;A驱动器
			INT 0x13		;调用磁盘BIOS
			JC ERROR

			%%%%%%%%%%%%%%%——————解释指令——————%%%%%%%%%%%%%%
			JC就是jump if carry，就是说有进位标志（carry flag）是1，则跳转

			INT 0x13, 要调用BIOS的0x13号函数，函数查询（http://community.osdev.info/?(AT)BIOS)

			13号函数：
			作用：磁盘读，写，扇区校验
			命令：
			AH=0x02（读盘）
			AH=0x03 (写盘)	
			AH=0x04（校验）
			AH=0x0c（寻道）
			AL=处理对象的扇区数（只能同时处理连续的扇区）
			CH=柱面号 &0xff
			CL=扇区号（0-5位）|（柱面号&0x300）>>2;
			DH=磁头号
			DL=驱动器号
			ES：BX=缓冲地址
			返回值
			FLACS:CF=0;没有错误，AH=0
			FLACS:CF=1;有错误，存入AH中


			这次调用的是AH=0x02，读盘的指令

			FLACS.CF就是进位标志，如果调用函数没错，这个FLACS.CF就是0，有错就是1，就跟那个JC指令结合起来了

当一个系统有多个软盘驱动器时，用驱动号制定从那个驱动器的软盘上读取数据，其实实际上的软盘物理结构跟一个大黑胶片差不多
是个圆盘，从外向内存储数据，正反两面都可以存，从外向内有80个圈我们把这个圈叫做柱面
然后每一面数据开始存储位置有一个针状的磁性设备，叫做磁头，用于开始记录数据，分别叫0号跟1号
每个圆环（柱面）再分为18个区，每个区就叫扇区
所以，一张软盘：80（柱面）*2（磁头）*18（扇区）*512（扇区能存的最大数据）=1474560 Btye=1440 KB
对于含有IPL的启动区，位于C0-H0-S1，（柱面0，磁头0，扇区1的缩写），下一个扇区是C0-H0-S2




缓冲区地址，是个内存地址，表明我们要把从软盘上面读取的数据存到内存的哪个位置，一般来说能用一个寄存器表示内存地址就行了，但是BX只有64K大小，太小
所以引入EBX寄存器，能处理4G内存，这就是CPU能处理的最大内存量
（但是没有EBX之前，使用的是段寄存器，以ES：BX形式写地址，当时的MOV AL，【ES：BX】

其实开发程序的话都要考虑这个段寄存器，指定地址时，一般都是'DS:'作为默认的段寄存器
汇编语言写地址，通常省略
但是正是因为这个规定，所以DS上必须不占数（0）

PS：软盘其实有时不能读数据    /笑

新增代码：
			MOV AX,0x0820
			MOV ES,AX
			MOV CH,0 		;柱面0
			MOV DH,0		;磁头0
			MOV CL,2		;扇区2

			MOV SI,0		;记录失败次数
		retry:
			MOV AH,0x02 	;AH=0x02，读入磁盘
			MOV AL,1		;1个扇区
			MOV BX,0		
			MOV DL,0X00 	;A驱动器
			INT 0x13 		;调用磁盘BIOS
			JNC fin			;没出错的话跳转到fin
			ADD SI,1		;SI加1
			CMP SI,5		;比较SI与5
			JAE ERROR		;SI>=5,跳转到error
			MOV AH,0x00
			MOV DL,0x08    	;A驱动器
			INT 0x13		;重置驱动器
			JMP retry

			解释代码
			JNC是jump if not carry跟JC相反，如果进位标志是0跳转
			JAE是jump if above or equal,大于或等于时跳转
